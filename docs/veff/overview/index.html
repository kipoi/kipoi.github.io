<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Overview - Kipoi-veff</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Overview";
    var mkdocs_page_input_path = "overview.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Kipoi-veff</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Overview</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#variant-effect-prediction">Variant effect prediction</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#how-it-works">How it works</a></li>
        
            <li><a class="toctree-l3" href="#in-silico-mutagenesis">In-silico mutagenesis</a></li>
        
            <li><a class="toctree-l3" href="#model-and-dataloader-requirements">Model and dataloader requirements</a></li>
        
            <li><a class="toctree-l3" href="#setting-up-the-modelyaml">Setting up the model.yaml</a></li>
        
            <li><a class="toctree-l3" href="#setting-up-the-dataloaderyaml">Setting up the dataloader.yaml</a></li>
        
            <li><a class="toctree-l3" href="#use-cases">Use-cases</a></li>
        
            <li><a class="toctree-l3" href="#scoring-functions">Scoring functions</a></li>
        
            <li><a class="toctree-l3" href="#output">Output</a></li>
        
            <li><a class="toctree-l3" href="#more-complex-models">More complex models</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Using</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../using/">Functions</a>
                </li>
                <li class="">
                    
    <a class="" href="../variant_effect_pred/">Variant effect prediction</a>
                </li>
                <li class="">
                    
    <a class="" href="../mutation_map/">Mutation maps</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Tutorials</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../tutorials/variant_effect_prediction_simple/">Simple</a>
                </li>
                <li class="">
                    
    <a class="" href="../tutorials/variant_effect_prediction/">Advanced</a>
                </li>
                <li class="">
                    
    <a class="" href="../tutorials/mutation_map/">Mutation map</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Api</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../api/score_variants/">score_variants</a>
                </li>
                <li class="">
                    
    <a class="" href="../api/predict_snvs/">predict_snvs</a>
                </li>
                <li class="">
                    
    <a class="" href="../api/scores/">Available scores</a>
                </li>
                <li class="">
                    
    <a class="" href="../api/MutationMap/">MutationMap</a>
                </li>
                <li class="">
                    
    <a class="" href="../api/MutationMapPlotter/">MutationMapPlotter</a>
                </li>
                <li class="">
                    
    <a class="" href="../api/KipoiVCFParser/">KipoiVCFParser</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Kipoi-veff</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Overview</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="http://github.com/kipoi/kipoi-veff/edit/master/docs/overview.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="variant-effect-prediction">Variant effect prediction</h1>
<p>Variant effect prediction offers a simple way predict effects of SNVs using any model that uses DNA sequence as an input. Many different scoring methods can be chosen but the principle relies on in-silico mutagenesis (see below). The default input is a VCF and the default output again is a VCF annotated with predictions of variant effects.</p>
<h2 id="how-it-works">How it works</h2>
<p>This sketch highlights the overall functionality of variant effect prediction. More details are given in the chapters below.</p>
<p><img alt='variant effect prediction sketch' src='../../img/overview/vep.png'></p>
<p>Dataloader output and a VCF are overlapped and the input DNA sequence is mutated as defined in the VCF. The reference and the alternative set of model inputs is predicted using the model and the differences are evaluated using a scoring function. The results are then stored in an annotated VCF.</p>
<h2 id="in-silico-mutagenesis">In-silico mutagenesis</h2>
<p>The principle relies on generating model predictions twice, once with DNA sequence that contains the reference and once with the alternative allele of a variant. Those predictions can then be compared in different ways to generate an effect prediction.</p>
<h3 id="scoring-methods">Scoring methods</h3>
<p>Scoring methods that come with Kipoi are <code>Diff</code> which simply calculates the difference between the two predictions, <code>Logit</code> which calculates the difference of <code>logit(prediction)</code> of the two predictions and a few more. Those scoring methods can also be user-defined in which case they can be submitted with the model. Not all scoring functions are compatible with all model possible model outputs - for example the logit transformation can only be performed on values [0,1].</p>
<h2 id="model-and-dataloader-requirements">Model and dataloader requirements</h2>
<p>The model has to produce predictions at least partly based on DNA sequence and the DNA sequence either has to be as a string (e.g. <code>acgtACGT</code>) or in a 1-hot encoded way in which A = <code>[1,0,0,0]</code>, C = <code>[0,1,0,0]</code>, G= <code>[0,0,1,0]</code>, T= <code>[0,0,0,1]</code>. Please note that any letter/base that is not in <code>acgtACGT</code> will be regarded and treated as <code>N</code> (in one-hot: <code>[0,0,0,0]</code>)!</p>
<p>Requirements for the dataloader are that apart from producing the model input it also has to output information which region of the genome this generated sequence corresponds. On a side note: This region is only used to calculate an overlap with the query VCF, hence as long the dataloader output refers to the same sequence assembly as the VCF file variant scoring will return the desired results.</p>
<h2 id="setting-up-the-modelyaml">Setting up the model.yaml</h2>
<p>In order to indicate that a model is compatible with Kipoi postprocessing the definition of <code>postprocessing</code> in the model.yaml file is necessary. The postprocessing section can then mention multiple different ways to interpret a model. Here we will discuss variant effect prediction, a sample section of the model.yaml can look like this:</p>
<pre><code class="yaml">postprocessing:
    variant_effects:
      seq_input:
        - seq
      use_rc: seq_only
</code></pre>

<p>This defines that the current model is capable to be used for variant effect prediction (<code>variant_effects</code>) and it defines that <code>seq</code> is the name of the model input that contains DNA sequence, which can be mutated and used for effect prediction. <code>seq_input</code> is a mandatory field and variant effect prediction can only be executed if there is at least one model input defined in <code>seq_input</code>. For some models it is necessary that also reverse-complements of DNA sequences are tested / predicted. To indicate that this is the case for the current model add the optional flag <code>use_rc: seq_only</code>. Using <code>seq_only</code> will reverse-complement <em>only</em> the model inputs that are defined in <code>seq_input</code>. Any other model input will remain untouched and exactly the same input will be fed to the model input as for the "forward" version of the model input.</p>
<p>As mentioned above the DNA sequence input may either be a string or 1-hot encoded. To indicate which format is used the <code>special_type</code> flag is used. The model input may then look like this:</p>
<pre><code class="yaml">schema:
    inputs:
        seq:
            shape: (101, 4)
            special_type: DNASeq
            doc: One-hot encoded RNA sequence
</code></pre>

<p>Here a one-hot encoded sequence (<code>DNASeq</code>) is expected to be the model input. Note that the model input label (here: <code>seq</code>) was used before in the <code>postprocessing</code> section and the same label is expected to be exist in the dataloader output.</p>
<p>The <code>special_type</code> flag for using string input sequences is: <code>DNAStringSeq</code>. So the following snippet of a model.yaml file</p>
<pre><code class="yaml">schema:
    inputs:
        seq:
            shape: ()
            special_type: DNAStringSeq
            doc: RNA sequence as a string
</code></pre>

<p>indicates that a single sample of <code>seq</code> is <code>np.array(string)</code> where <code>string</code> is a python string.</p>
<p>If <code>special_type</code> is not defined for a model input, but it is used in <code>seq_input</code> in the <code>postprocessing</code> section, then by default Kipoi expects one-hot encoded DNA sequences.</p>
<h2 id="setting-up-the-dataloaderyaml">Setting up the dataloader.yaml</h2>
<p>Similar to the model.yaml also <code>dataloader.yaml</code>has to have a <code>postprocessing</code> section defined to indicate that it is compatible with variant effect prediction. As a bare minimum the following has to be defined:</p>
<pre><code class="yaml">postprocessing:
    variant_effects:
</code></pre>

<p>And equally important every DNA sequence input of a model (here <code>seq</code>) has to have an associated metadata tag, which could like follows:</p>
<pre><code class="yaml">output_schema:
    inputs:
        seq:
            shape: (101, 4)
            special_type: DNASeq
            doc: One-hot encoded RNA sequence
            associated_metadata: ranges
        some_other_input:
            shape: (1, 10)
            doc: Some description
    metadata:
        ranges:
            type: GenomicRanges
            doc: Ranges describing inputs.seq
</code></pre>

<p>Here the <code>associated_metadata</code> flag in the input field <code>seq</code> is set to <code>ranges</code>, which means that for every sample in the <code>model_input['inputs']['seq']</code> one entry in <code>model_input['metadata']['ranges']</code> is expected with its type either being <code>GenomicRanges</code> or a dictionary of numpy arrays with the keys <code>chr</code>, <code>start</code>, <code>end</code>, <code>id</code>. The information in the metadata object gives variant effect prediction the possibilty to find the relative position of a variant within a given input sequence. Hence the <code>associated_metadata</code> is mandatory for every  entry in <code>seq_input</code> in the model.yaml file. Please note that the coordinates in the metadata are expected to be 0-based, hence comply with .bed file format!</p>
<p>The following sketch gives an overview how the different tags play together and how they are used with variant effect prediction.</p>
<p><img alt='variant effect prediction sketch with dataloader details' src='../../img/overview/variant_effect_prediction_intro.png'></p>
<h2 id="use-cases">Use-cases</h2>
<p>This section describes a set of functions which cover most of the common queries for variant effect. All of the functions described below require that the model.yaml and dataloader.yaml files are set up in the way defined above.</p>
<p>In literature in-silico mutagenesis-based variant effect predcition is performed in a variant centric way: Starting from a VCF for every variant a sequence centered on said variant is generated. That sequence is then mutated by modifying the central base and setting it to what is defined as reference or alternative allele, generating two sets of sequences. For both the set with the reference allele in the center and the alternative allele in the center the model prediction is run and model outputs are compared.</p>
<p>Not all models can predict on aribrary DNA sequences from any region of the genome. Splicing models may for example only be trained on regions surrounding a splice site, hence the variant-centered approach from before will not work. Therefore two more options to run variant effect predicion are offered: restricted variant centered effect prediction and overlap-based effect prediction.</p>
<p>Variant effect prediction will try to use variant-centered approaches whenever the <code>bed_input</code> flag is defined in dataloader.yaml (see below). Otherwise the overlap-based effect prediction is used. This is because the variant centered approach is generally faster and for every variant in the VCF one single prediction can be made (assuming the position of variant is in a valid genomic region).</p>
<p>For all the methods described below it is essential that genomic coordinates in the VCF and the coordinates used by the dataloader are for the same genome / assembly /etc.</p>
<h3 id="variant-centered-effect-prediction">Variant centered effect prediction</h3>
<p>In order to use variant centered effect prediction the dataloader must accept an input bed file based on which it will produce model input. Furthermore the dataloader is required to return the name values (fourth column) of the input bed file in the <code>id</code> field of <code>model_input['metadata']['ranges']</code>. Additionally the order of samples has to be identical with the order of regions in the input bed file, but regions may be skipped.</p>
<p>In order for the variant effect prediction to know which input argument of the dataloader is accepts a bed file three additional lines in dataloader.yaml are necessary, e.g:</p>
<pre><code class="yaml">postprocessing:
    variant_effects:
      bed_input:
        - intervals_file
</code></pre>

<p>This section indicates that the dataloader function has an argument <code>intervals_file</code> which accepts a bed file path as input which may be used.</p>
<p><img alt='variant effect prediction sketch' src='../../img/overview/vep_centered.png'></p>
<h3 id="restricted-variant-centered-effect-prediction">Restricted-variant centered effect prediction</h3>
<p>Requirements for the dataloader and dataloader.yaml here are identical to the variant centered effect prediction. The only difference is that this function is designed for models that can't predict on arbitrary regions of the genome, but only in certain regions of the genome. If those regions can be defined in a bed file (further on called 'restriction-bed' file) then this approach can be used. Variant effect prediction will then intersect the VCF with the restriction-bed and generate another bed file that is then passed on to the dataloader.</p>
<p>Regions in the restriction-bed file may be larger than the input sequence lenght, in that case the generated seuqence will be centered on the variant position as much as possible - restricted by what is defined in the restrictions-bed file.
<img alt='variant effect prediction sketch' src='../../img/overview/vep_restr_bed.png'></p>
<h3 id="overlap-based-effect-prediction">Overlap-based effect prediction</h3>
<p>If the dataloader does not support bed input files then variant effect predictions can be run by the overlap of a VCF with the regions defined in the metdata output of the dataloader.</p>
<p>If multiple variants overlap with a region then the effect will be predicted inpendently for those variants. If multiple (e.g.: two) model input samples overlap with one variant then the output will contain as many predictions as there were independent overlaps of metadata ranges and variants (e.g.: two).
<img alt='variant effect prediction sketch' src='../../img/overview/vep.png'></p>
<h2 id="scoring-functions">Scoring functions</h2>
<p>After mutating the model input DNA sequences predictions are created using the models and those predictions then have to compared by scoring methods. Not all scoring methods are compatible with all models depending on the output data range of the model (see below). The compatibility of a scoring function with a given model can be indicated by setting <code>scoring_functions</code> in model.yaml:</p>
<pre><code class="yaml">postprocessing:
   variant_effects
      seq_input:
        - seq
      scoring_functions:
        - name: diff
          type: diff
        - type: logit
          default: true
</code></pre>

<p>The scoring function is identified by the <code>type</code> field in <code>scoring_functions</code> which is the only mandatory field. Allowed values for the <code>type</code> field are: <code>diff</code>, <code>logit</code>, <code>deepsea_effect</code> and <code>custom</code>.</p>
<p>Setting <code>default:true</code> for a scoring function indicates that that respective scoring function is executed by variant effect prediction if none is selected by the used on execution time. If multiple scoring functions have set <code>default:true</code> then all of those will be run by default. If <code>default:true</code> is not set for any scoring function defined in <code>scoring_functions</code> then all entries in <code>scoring_functions</code> will be run by default.</p>
<p>Scoring functions can be assigned a different name with the <code>name</code> flag by which they are then selected using the command line interface. In general it is not advisable to rename the scoring functions that come with Kipoi.</p>
<h4 id="diff">Diff</h4>
<p>The simplest scoring method is to calculate the difference between predictions for the reference and the alternative allele: <code>prediction(alt) - prediction(ref)</code>. This scoring method is available for all models no matter if it is defined in <code>scoring_functions</code> or not.</p>
<h4 id="logit">Logit</h4>
<p>Calculates the difference of logit-transformed values of the predictions:
<code>logit(prediction(alt)) - logit(prediction(ref))</code>. This scoring method only makes sense if the model output can be interpreted as probabilities. In a wider sense, it will only produce valid values if the predictions are in the range [0,1].</p>
<h4 id="logitalt">LogitAlt</h4>
<p>Returns the logits transformed predictions for the sequences carrying the alternative allele:
<code>logit(prediction(alt))</code>. This scoring method only makes sense if the model output can be interpreted as probabilities. In a wider sense, it will only produce valid values if the predictions are in the range [0,1].</p>
<h4 id="logitref">LogitRef</h4>
<p>Returns the logits transformed predictions for the sequences carrying the reference allele:
<code>logit(prediction(ref))</code>. This scoring method only makes sense if the model output can be interpreted as probabilities. In a wider sense, it will only produce valid values if the predictions are in the range [0,1].</p>
<h4 id="deepsea_effect">Deepsea_effect</h4>
<p>Calculates the variant scores as defined in the publication of the DeepSEA model (Troyanskaya et al., 2015) by using the absolute value of the logit difference and diff values multiplied together: <code>abs(Logit * Diff)</code> with <code>Logit</code> and <code>Diff</code> defined as above.</p>
<h4 id="custom">Custom</h4>
<p>Custom scoring methods can be defined and shipped with the models. In that case the model.yaml will look similar to this:</p>
<pre><code class="yaml">postprocessing:
  variant_effects:
    seq_input:
      - seq
    scoring_functions:
      - name: my_scores
        type: custom
        defined_as: postproc.py::myfun
        args:
          first_arg:
            doc: Description of the first argument
            default: 1
</code></pre>

<p>Notice that the selection of <code>type: custom</code> requires that <code>defined_as</code> is set. The value <code>postproc.py::myfun</code> indicates that the callable python object <code>myfun</code> is stored in a file called <code>postproc.py</code>. When executing variant effect prediction in the command line the scoring function can be chosen by it's name - which in this case is: <code>my_scores</code>.</p>
<p>All scoring functions are subclasses of <code>Rc_merging_pred_analysis</code> this means that also a custom scoring function must inherit from it.</p>
<h2 id="output">Output</h2>
<p>The output of variant effect prediction is by default stored in a VCF that is derived from the input VCF. The output VCF only contains variants for which a effect prediction could be generated (e.g. if no model input sample overlapped a variant no prediction could be made for it). The predictions themselves are stored in the INFO field of the VCF, with the ID starting with <code>KPVEP</code> and containing the name of the model. Additional to the predictions themselves a also a region ID will be stored in a second INFO field. The region IDs are the values stored in <code>model_input['metadata']['ranges']['id']</code> given to a sequence sample generated by the dataloader. This way it is possible to trace back which sequence was mutated by which variant in order to produce a certain effect prediction</p>
<p>Since multiple seqeunces generated by the dataloader may overlap one variant - especially when using the overlap-based effect prediction - it is possible that the generated VCF output will contain a variant multiple times, but the different predictions will be destinguishable by their region ID.</p>
<p>If variant effect prediction is run programmatically in python then the results are returned as a dictionary of pandas DataFrames.</p>
<h2 id="more-complex-models">More complex models</h2>
<p>More complex models may have more than only one DNA sequence input, it may even be that models have DNA sequence inputs taken from different regions of the genome within one sample in a batch. See this sketch for an illustration of the scenario:</p>
<p><img alt='variant effect prediction sketch' src='../../img/overview/variant_effect_prediction_intro_complex.png'></p>
<p>The dataloader has three sequence outputs which are linked to two metadata ranges. for both ranges objects the beginning of the ranges is displayed. In order to overlap the metadata ranges with variants the input batch is processed one sample at a time. The samples in a batch are displayed in green rectangular boxes: For every sample all the ranges are assembled and overlapped with variants in the VCF. Then the effect is predicted for every single variant in the VCF that overlaps at least one of the region defined in that sample. This means that for the first sample in the batch two variants are investigated: rs1 and rs2. rs1 can only affect seq1a and seq1b, hence those two sequences are mutated, seq2 is not. rs2 overlaps with both ranges in the first sample and hence two sequences are mutated with rs2 to predict its effect. This means that the first sample will be evaluated twice using variants rs1 and rs2, and the second sample only once using rs3.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../using/" class="btn btn-neutral float-right" title="Functions">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="http://github.com/kipoi/kipoi-veff/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../using/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
